# QueryDSL MySQL JSON - SQL Module

[![Maven Central](https://img.shields.io/badge/Maven%20Central-0.1.0--Dev.3-blue.svg)]()
[![Java: 17+](https://img.shields.io/badge/Java-17%2B-orange.svg)](https://www.oracle.com/java/technologies/javase-jdk17-downloads.html)
[![QueryDSL: 7.1](https://img.shields.io/badge/QueryDSL-7.1-blue.svg)](https://github.com/OpenFeign/querydsl)

Type-safe MySQL JSON function support for QueryDSL SQL module.

---

## Table of Contents

- [Overview](#overview)
- [Installation](#installation)
- [Quick Start](#quick-start)
  - [1. Configuration](#1-configuration)
  - [2. Basic Usage](#2-basic-usage)
  - [3. Fluent API](#3-fluent-api)
- [Function Categories](#function-categories)
- [Advanced Usage](#advanced-usage)
- [Integration](#integration)
- [API Reference](#api-reference)
- [FAQ](#faq)

---

## Overview

The SQL module provides type-safe access to all 35 MySQL JSON functions through QueryDSL SQL. It extends QueryDSL's `MySQLTemplates` to register JSON operators and provides two main APIs:

- **`SqlJsonFunctions`**: Static utility methods for direct function calls
- **`SqlJsonExpression`**: Fluent API wrapper for method chaining

**Key Features**:
- ✅ All 35 MySQL 8.0.17+ JSON functions
- ✅ Type-safe queries with compile-time checking
- ✅ IDE autocompletion and refactoring support
- ✅ Seamless integration with QueryDSL SQL
- ✅ No JPA/Hibernate dependency

---

## Installation

### Gradle

```gradle
dependencies {
    // Core module (required)
    implementation 'io.github.snowykte0426:querydsl-mysql-json-core:0.1.0-Beta.4'

    // SQL module
    implementation 'io.github.snowykte0426:querydsl-mysql-json-sql:0.1.0-Beta.4'

    // QueryDSL SQL (if not already included)
    implementation 'io.github.openfeign.querydsl:querydsl-sql:7.1'

    // MySQL Connector
    implementation 'com.mysql:mysql-connector-j:8.2.0'

    // Connection pool (recommended)
    implementation 'com.zaxxer:HikariCP:5.1.0'
}
```

### Maven

```xml
<dependencies>
    <!-- Core module -->
    <dependency>
        <groupId>io.github.snowykte0426</groupId>
        <artifactId>querydsl-mysql-json-core</artifactId>
        <version>0.1.0-Beta.4</version>
    </dependency>

    <!-- SQL module -->
    <dependency>
        <groupId>io.github.snowykte0426</groupId>
        <artifactId>querydsl-mysql-json-sql</artifactId>
        <version>0.1.0-Beta.4</version>
    </dependency>

    <!-- QueryDSL SQL -->
    <dependency>
        <groupId>io.github.openfeign.querydsl</groupId>
        <artifactId>querydsl-sql</artifactId>
        <version>7.1</version>
    </dependency>

    <!-- MySQL Connector -->
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <version>8.2.0</version>
    </dependency>
</dependencies>
```

---

## Quick Start

### 1. Configuration

First, configure QueryDSL SQL with `MySQLJsonTemplates`:

```java
import sql.io.github.snowykte0426.querydsl.mysql.json.MySQLJsonTemplates;
import com.querydsl.sql.Configuration;
import com.querydsl.sql.SQLQueryFactory;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import javax.sql.DataSource;

public class QueryDslConfig {

    public static SQLQueryFactory createQueryFactory() {
        // 1. Create configuration with JSON support
        Configuration configuration = new Configuration(MySQLJsonTemplates.DEFAULT);

        // 2. Setup DataSource
        DataSource dataSource = createDataSource();

        // 3. Create and return SQLQueryFactory
        return new SQLQueryFactory(configuration, dataSource);
    }

    private static DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
        config.setUsername("user");
        config.setPassword("password");
        config.setDriverClassName("com.mysql.cj.jdbc.Driver");
        return new HikariDataSource(config);
    }
}
```

### 2. Basic Usage

Use `SqlJsonFunctions` for direct function calls:

```java
import sql.io.github.snowykte0426.querydsl.mysql.json.SqlJsonFunctions;
import com.querydsl.core.Tuple;
import com.querydsl.sql.SQLQueryFactory;

import java.util.List;

public class UserRepository {

    private final SQLQueryFactory queryFactory;

    // Assume QUser is generated by QueryDSL SQL codegen
    private final QUser user = QUser.user;

    public List<Tuple> findAdminUsers() {
        return queryFactory
            .select(user.name, user.email)
            .from(user)
            .where(SqlJsonFunctions.jsonExtract(user.metadata, "$.role")
                .eq("\"admin\""))  // Note: JSON strings need quotes
            .fetch();
    }

    public List<Tuple> findUsersByMetadataKey(String key) {
        return queryFactory
            .select(user.name)
            .from(user)
            .where(SqlJsonFunctions.jsonContainsPath(user.metadata, "one", "$." + key))
            .fetch();
    }

    public List<Tuple> aggregateUserEmails() {
        return queryFactory
            .select(
                user.department,
                SqlJsonFunctions.jsonArrayAgg(user.email)
            )
            .from(user)
            .groupBy(user.department)
            .fetch();
    }
}
```

### 3. Fluent API

Use `SqlJsonExpression` for method chaining:

```java
import expressions.sql.io.github.snowykte0426.querydsl.mysql.json.SqlJsonExpression;
import com.querydsl.core.Tuple;

import java.util.List;

public class ProductRepository {

    private final SQLQueryFactory queryFactory;
    private final QProduct product = QProduct.product;

    public List<Tuple> findComplexProducts() {
        // Wrap the JSON column
        SqlJsonExpression attributes = SqlJsonExpression.of(product.attributes);

        return queryFactory
            .select(product.name, product.price)
            .from(product)
            .where(
                attributes.extract("$.category").eq("\"electronics\"")
                    .and(attributes.depth().lt(10))
                    .and(attributes.length().gt(5))
            )
            .fetch();
    }

    public List<Tuple> findProductsWithFeature(String feature) {
        SqlJsonExpression attributes = SqlJsonExpression.of(product.attributes);

        return queryFactory
            .select(product.name)
            .from(product)
            .where(attributes.contains("\"" + feature + "\"", "$.features"))
            .fetch();
    }
}
```

---

## Function Categories

All 35 MySQL JSON functions are available:

### Creation Functions (3)

| Function | Description | Example |
|----------|-------------|---------|
| `jsonArray()` | Create JSON array | `SqlJsonFunctions.jsonArray("a", "b", "c")` |
| `jsonObject()` | Create JSON object | `SqlJsonFunctions.jsonObject("key", "value")` |
| `jsonQuote()` | Quote string as JSON | `SqlJsonFunctions.jsonQuote("text")` |

### Search Functions (10)

| Function | Description | MySQL Version |
|----------|-------------|---------------|
| `jsonExtract()` | Extract data from JSON | All |
| `jsonValue()` | Extract scalar value | 8.0.21+ |
| `jsonUnquoteExtract()` | Extract and unquote (`->>`) | All |
| `jsonContains()` | Check if JSON contains value | All |
| `jsonContainsPath()` | Check if path exists | All |
| `jsonKeys()` | Get object keys | All |
| `jsonSearch()` | Find path to value | All |
| `jsonOverlaps()` | Check if two JSONs overlap | 8.0.17+ |
| `memberOf()` | Check array membership | 8.0.17+ |
| `jsonLength()` | Get element count | All |

### Modification Functions (9)

| Function | Description |
|----------|-------------|
| `jsonSet()` | Insert or update value |
| `jsonInsert()` | Insert without replacement |
| `jsonReplace()` | Replace existing values |
| `jsonRemove()` | Remove data from JSON |
| `jsonArrayAppend()` | Append to array |
| `jsonArrayInsert()` | Insert into array |
| `jsonMergePatch()` | Merge with RFC 7386 |
| `jsonMergePreserve()` | Merge preserving duplicates |
| `jsonUnquote()` | Unquote JSON string |

### Attribute Functions (4)

| Function | Description |
|----------|-------------|
| `jsonDepth()` | Get maximum depth |
| `jsonLength()` | Get element count |
| `jsonType()` | Get value type |
| `jsonValid()` | Validate JSON |

### Utility Functions (3)

| Function | Description |
|----------|-------------|
| `jsonPretty()` | Format JSON for readability |
| `jsonStorageSize()` | Get storage size in bytes |
| `jsonStorageFree()` | Get freed space after update |

### Schema Validation (2)

| Function | Description | MySQL Version |
|----------|-------------|---------------|
| `jsonSchemaValid()` | Validate against JSON schema | 8.0.17+ |
| `jsonSchemaValidationReport()` | Get validation report | 8.0.17+ |

### Aggregate Functions (2)

| Function | Description |
|----------|-------------|
| `jsonArrayAgg()` | Aggregate values into array |
| `jsonObjectAgg()` | Aggregate key-value pairs |

### Table Functions (1)

| Function | Description |
|----------|-------------|
| `jsonTable()` | Convert JSON to relational table |

---

## Advanced Usage

### Complex Queries with Joins

```java
public class OrderRepository {

    private final QUser user = QUser.user;
    private final QOrder order = QOrder.order;

    public List<Tuple> findOrdersWithJsonData() {
        return queryFactory
            .select(
                user.name,
                SqlJsonFunctions.jsonExtract(order.orderData, "$.items"),
                SqlJsonFunctions.jsonLength(order.orderData, "$.items").as("itemCount")
            )
            .from(order)
            .join(user).on(order.userId.eq(user.id))
            .where(
                SqlJsonFunctions.jsonContains(order.orderData, "\"laptop\"", "$.items")
                    .and(SqlJsonFunctions.jsonExtract(user.metadata, "$.role").eq("\"premium\""))
            )
            .fetch();
    }
}
```

### JSON_TABLE Example

```java
public void processJsonData(String jsonData) {
    // Note: JSON_TABLE requires native SQL with QueryDSL
    String sql = "SELECT jt.* FROM JSON_TABLE('" + jsonData + "', '$[*]' " +
        "COLUMNS(" +
        "  id INT PATH '$.id', " +
        "  name VARCHAR(100) PATH '$.name', " +
        "  email VARCHAR(255) PATH '$.email'" +
        ")) AS jt";

    // Execute using connection
    try (Connection conn = dataSource.getConnection();
         Statement stmt = conn.createStatement();
         ResultSet rs = stmt.executeQuery(sql)) {

        while (rs.next()) {
            int id = rs.getInt("id");
            String name = rs.getString("name");
            String email = rs.getString("email");
            // Process results...
        }
    }
}
```

### Update Operations

```java
public void updateUserMetadata(Long userId, String newRole) {
    long affected = queryFactory
        .update(user)
        .set(user.metadata,
            SqlJsonFunctions.jsonSet(user.metadata, "$.role", "\"" + newRole + "\""))
        .where(user.id.eq(userId))
        .execute();
}
```

### Aggregate Functions

```java
public Map<String, String> aggregateByDepartment() {
    List<Tuple> results = queryFactory
        .select(
            user.department,
            SqlJsonFunctions.jsonArrayAgg(user.name)
        )
        .from(user)
        .groupBy(user.department)
        .fetch();

    return results.stream()
        .collect(Collectors.toMap(
            t -> t.get(user.department),
            t -> t.get(1, String.class)
        ));
}
```

### Working with JSON_CONTAINS

The `jsonContains` function tests whether a JSON document contains a specific value. MySQL's `JSON_CONTAINS()` requires values to be valid JSON, which can be inconvenient for simple string or numeric searches.

#### Option 1: Manual JSON Escaping (Traditional)

```java
// For string values, you need to escape manually
public List<User> findUsersByRole(String role) {
    return queryFactory
        .selectFrom(user)
        .where(SqlJsonFunctions.jsonContains(
            user.roles,
            "\"" + role + "\""  // Note the escaped quotes
        ))
        .fetch();
}

// For numeric values
BooleanExpression hasId = SqlJsonFunctions.jsonContains(
    product.features,
    "42"  // Numbers don't need quotes
);
```

#### Option 2: Auto-Escaping (Recommended, 0.1.0-Beta.4+)

Use convenience methods for automatic escaping:

```java
// String values - no manual escaping needed!
public List<User> findUsersByRole(String role) {
    return queryFactory
        .selectFrom(user)
        .where(SqlJsonFunctions.jsonContainsString(
            user.roles,
            role  // Automatically escaped to "\"role\""
        ))
        .fetch();
}

// With path parameter
BooleanExpression hasScope = SqlJsonFunctions.jsonContainsString(
    apiKey.metadata,
    "student:read",
    "$.scope"
);

// Numeric values
BooleanExpression hasId = SqlJsonFunctions.jsonContainsNumber(
    product.features,
    42
);

BooleanExpression hasPrice = SqlJsonFunctions.jsonContainsNumber(
    product.metadata,
    99.99,
    "$.price"
);

// Boolean values
BooleanExpression isActive = SqlJsonFunctions.jsonContainsBoolean(
    user.settings,
    true,
    "$.active"
);
```

#### Real-World Example: API Scopes

```java
// Before (manual escaping, error-prone):
public List<ApiKey> findByScope(String scope) {
    return queryFactory
        .selectFrom(apiKey)
        .where(SqlJsonFunctions.jsonContains(
            apiKey.scopes,
            "\"" + scope + "\""  // Easy to forget quotes!
        ))
        .fetch();
}

// After (automatic escaping, cleaner):
public List<ApiKey> findByScope(String scope) {
    return queryFactory
        .selectFrom(apiKey)
        .where(SqlJsonFunctions.jsonContainsString(
            apiKey.scopes,
            scope  // No manual escaping needed
        ))
        .fetch();
}
```

---

## Integration

### Spring Boot Integration

**1. Add Configuration Bean:**

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class QueryDslSqlConfig {

    @Bean
    public com.querydsl.sql.Configuration querydslConfiguration() {
        return new com.querydsl.sql.Configuration(MySQLJsonTemplates.DEFAULT);
    }

    @Bean
    public SQLQueryFactory queryFactory(
            DataSource dataSource,
            com.querydsl.sql.Configuration configuration) {
        return new SQLQueryFactory(configuration, dataSource);
    }
}
```

**2. Use in Service:**

```java
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private final SQLQueryFactory queryFactory;

    public UserService(SQLQueryFactory queryFactory) {
        this.queryFactory = queryFactory;
    }

    public List<UserDto> findAdminUsers() {
        QUser user = QUser.user;

        return queryFactory
            .select(user.id, user.name, user.email)
            .from(user)
            .where(SqlJsonFunctions.jsonExtract(user.metadata, "$.role")
                .eq("\"admin\""))
            .fetch()
            .stream()
            .map(this::toDto)
            .collect(Collectors.toList());
    }
}
```

### Connection Pool Setup

**HikariCP (Recommended):**

```java
@Bean
public DataSource dataSource() {
    HikariConfig config = new HikariConfig();
    config.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
    config.setUsername("user");
    config.setPassword("password");
    config.setDriverClassName("com.mysql.cj.jdbc.Driver");

    // Optimization
    config.setMaximumPoolSize(10);
    config.setMinimumIdle(5);
    config.setConnectionTimeout(30000);
    config.setIdleTimeout(600000);
    config.setMaxLifetime(1800000);

    return new HikariDataSource(config);
}
```

### Transaction Management

```java
@Service
public class OrderService {

    private final SQLQueryFactory queryFactory;
    private final DataSource dataSource;

    @Transactional
    public void createOrderWithMetadata(Order order, String metadata) {
        QOrder qOrder = QOrder.order;

        Long orderId = queryFactory
            .insert(qOrder)
            .set(qOrder.userId, order.getUserId())
            .set(qOrder.totalAmount, order.getTotalAmount())
            .set(qOrder.orderData, metadata)
            .executeWithKey(qOrder.id);

        // Additional operations within transaction...
    }
}
```

---

## API Reference

### Core Classes

- **[`MySQLJsonTemplates`](src/main/java/com/github/snowykte0426/querydsl/mysql/json/sql/MySQLJsonTemplates.java)**: QueryDSL SQL templates with JSON support
- **[`SqlJsonFunctions`](src/main/java/com/github/snowykte0426/querydsl/mysql/json/sql/SqlJsonFunctions.java)**: Static utility methods for all JSON functions
- **[`SqlJsonExpression`](src/main/java/com/github/snowykte0426/querydsl/mysql/json/sql/expressions/SqlJsonExpression.java)**: Fluent API wrapper

### JavaDoc

Complete JavaDoc documentation is available inline with all classes. Each method includes:
- Function description
- SQL equivalent
- Parameter documentation
- Return type
- Usage examples

---

## FAQ

### Q: Do I need the Core module?

**A:** Yes, the Core module is required as it contains all function implementations. The SQL module only provides integration with QueryDSL SQL.

### Q: How do I quote JSON strings?

**A:** JSON string values must be quoted:
```java
// Correct
.where(expr.eq("\"admin\""))

// Incorrect
.where(expr.eq("admin"))
```

### Q: Can I use this with JPA?

**A:** No, use the `querydsl-mysql-json-jpa` module instead. The SQL module is for QueryDSL SQL only.

### Q: How do I generate Q-types?

**A:** Use QueryDSL SQL code generation:
```gradle
dependencies {
    implementation 'io.github.openfeign.querydsl:querydsl-sql-codegen:7.1'
}
```

See [QueryDSL SQL documentation](http://querydsl.com/static/querydsl/latest/reference/html/ch02s03.html) for details.

### Q: What MySQL version is required?

**A:** MySQL 8.0.17+ is required for all functions. Some functions (JSON_VALUE, JSON_OVERLAPS, MEMBER OF) require 8.0.21+.

### Q: How do I handle NULL values?

**A:** JSON NULL is different from SQL NULL:
```java
// JSON null value
SqlJsonFunctions.jsonNull()

// SQL NULL
Expressions.nullExpression()
```

---

## Related Documentation

- [Main Project README](../README.md)
- [Core Module](../querydsl-mysql-json-core/README.md)
- [JPA Module](../querydsl-mysql-json-jpa/README.md)
- [Integration Guide](../INTEGRATION_GUIDE.md)
- [Function Reference](../FUNCTIONS.md)
- [MySQL JSON Functions](https://dev.mysql.com/doc/refman/8.0/en/json-functions.html)

---

## License

This project is licensed under the MIT License - see the [LICENSE](../LICENSE) file for details.
